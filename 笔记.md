## 流程

`node/src/benchmark_client.rs` 作为发送端，初始化 TransactionsClient，调用 client.submit_transaction_stream() 发送交易。

Worker 通过 `worker/src/worker.rs:416` submit_transaction_stream() 函数接收交易列表，将交易列表中的交易逐个传输到 tx_batch_maker channel 中

rx_batch_maker 吐出交易，会被 BatchMaker 接收，见 `worker/src/batch_maker.rs`，BatchMaker 会将交易打包成一个 Batch。当 current_batch_size >= self.batch_size 或超时时，BatchMaker 会调用 seal 函数，打包出 batch，并将 batch 传输到 tx_quorum_waiter channel 中。

`worker/src/quorum_waiter.rs` QuorumWaiter 负责同时向其他 Worker 广播信息，等待到达 quorum_size 个 Worker 后，将 batch 传输到 tx_client_processor 中。

Processor 接收 batch，储存 batch，将 batch 的哈希传输到 PrimaryConnector（通过 tx_primary）

PrimaryConnector 通过 rx_primary 接收消息，将消息传输到 Primary

// TODO
对于 Primary，WorkerReceiverHandler `primary/src/primary.rs:549` 从 worker 接收消息。

## 常用脚本

```sh
cd q
go run . build # 编译
go run . req # 发送交易

dcu && docker compose exec -T q-dev /workspace/q/script/proto.sh # 生成 proto 文件
```

## 架构

- qexecutor 服务: 执行交易，产生检查点。生成时间证明
- qmaster 服务: mempool master 节点
- qworker 服务: mempool worker 节点